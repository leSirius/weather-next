home和search主要是抓取数据方式不同：home在客户端组件抓数据，服务端只能渲染一个骨架屏；search在服务端抓数据传给客户端组件。

## home性能

这个应用的home页面关键渲染路径过长，有三个存在数据依赖的请求（还只是数据请求，而且地理位置需要用户许可权限才可以拿）。浏览器获取html请求js，然后js先利用浏览器api获取客户端经纬度坐标，然后向服务端发送该信息获取城市id，客户端子组件们获取id后再发送请求天气数据。
对比之下，search和home几乎需要一样的数据量来渲染页面，search通常快一些。严格来说，search多一个热门城市列表的请求，但有流式渲染并行执行，实际没有影响。

### 改进

获取地理位置的另一个可行方案是客户端发起请求，服务端利用IP通过第三方提供的接口获取地理位置或者id，服务端利用收到的信息继续请求然后返回客户端，不过和风天气没有提供这样的接口。

因为地理位置必须在客户端获取，没找到太好方案，所以不太地道地用中间件把默认页面改成search页面，search页面来请求用户权限，拿到位置存进sessionStorage，切换到home时，直接从存储拿位置，在这种情况下可以省去第一个请求。
用useLayoutEffect会有五到十毫秒的微雕提前，骨架屏在html里绘制好了，所以useLayoutEffect阻塞渲染的副作用在这里没有影响。

后续对id的请求依赖没有继续优化。一个应该可行的优化方案是，在服务端缓存地理信息与id，这样客户端从sessionStorage获取地理信息后就可以直接请求天气信息，在理想情况下（从search跳转home后），请求链可以从3个缩减为1个（确切是多个并行发出）。

## search页面

流式渲染下DCL指标不是很好看，因为渲染的过程也是等待数据的过程，到DCL发出时，页面数据基本绘制完成。CSR总要到load事件以后才发出数据请求。

### 切换数据延迟优化
在home页面中，中间组件(MiddleBoard)切换数据种类的按钮点击会请求数据，所以存在一点延迟。这里结合了服务端和客户端抓取数据，模仿Next.js `<Link>`的预抓取方法，SWR策略，以及ETAG减少数据包体积（本来数据也蛮小的）的方法进行了优化。这些优化的一个重要前提是，天气数据不太讲究时效性，和风天气的推荐重验证时间也是30-60分钟。

Middle组件的初始渲染数据（每次url发生变化）总是由服务端组件提供，客户端组件渲染后，监听load事件，预抓取其余两种数据进入缓存。每当切换数据种类时，先检查缓存，如果没有数据就发起请求；有则直接呈现缓存数据，然后使用向服务器ETAg校验数据是否过期，过期返回新数据，未过期返回304。切换显示城市时会重复上述流程。
大多数时候服务器也不会向数据源校验，这里还有一层Next.js的Data Cache缓存，设置每小时才会向数据源校验一次。不过这种基于时间的校验策略似乎存在一个纰漏，当一个数据需要校验时，服务器收到请求还是会直接回旧数据，然后向数据源发起校验，所以这次的数据请求很可能是过时的。


为了在切换城市时保留当前的数据种类，需要middle组件与切换城市的组件有单向通信告知当前数据类型（只有后者改变当前url），但它们的最低公共父节点是page而且要跨越服务端组件，使用了useContext包裹page组件传递；另一个可行方案是event bus，只是不太符合react通常的单向数据流。
因为只有城市列表可以改变url，所以在Middle点选数据类型时，并不会引起匹配的url修改，会导致url与的当前显示不匹配。而且，改变url的初始渲染总是使用服务端抓取数据，不会最大化利用缓存。

这里又遇到了state连锁更新的问题。这里点选按钮切换，如果先改witchFetch状态（数据种类），然后引起监听这个变量的呈现数据（showData）状态的改变，会引起至少两次react渲染，既不必要，也可能出问题。在两次渲染切割的三个时间片中，中间的那个数据是不相匹配的，witchFetch已经改变而showData还没有变。
因为用的prevWitchFetch状态监听，而不是useEffect，渲染遇到新的setState会适时停止，所以还没有遇上报错，而这时同步的情况。（如果所切换的数据尚未缓存会报错，第二个时间片要到异步请求的数据到达才结束，React渲染会执行完，因为预抓取这个情况不太会发生）
把它们合并进按钮的监听函数进行一次React渲染更好一些，然后会又发现witchFetch没必要作为一个state。同步的重渲染应当只进行一次。


### 复用组件

关于复用，服务端与客户端的主要区别在于数据抓取方式不同。如果各个子组件是使用要渲染的数据而不是id作为参数的话，这些子组件基本都是可以直接复用的。给它们加专门抓取数据的中间层，或者统一在page组件抓取可以做到这一点。


