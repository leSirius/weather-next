### search页面

服务端抓取数据渲染的页面。因为next.js具备full route cache和data cache两层持久缓存，这个页面返回的html大概率已经带有了从缓存拿到的数据。

**切换数据延迟优化**

在home页面中，中部显示组件(Middle)切换数据种类的按钮点击会请求数据，所以存在一点延迟。这里结合了服务端和客户端抓取数据，仿照Next.js `<Link>`的预抓取方法，SWR缓存，以及使用`If-Non-Match`请求头（本来数据也蛮小的）进行了优化。

Middle组件的初始渲染数据（每次url发生变化时）总是由服务端组件提供，页面load以后（后续是useEffect监听id），客户端组件预抓取其余两种数据进入缓存。每当切换数据种类时，先检查缓存，如果没有数据就发起请求；有则直接呈现缓存数据，然后使用数据观测时间作`If-Non-Match`的值发送请求，过期返回新数据，未过期返回304。切换城市会重复该流程。

大多数时候服务器也不会向数据源校验，这里还有一层Next.js的Data Cache缓存，设置每小时向数据源校验一次。（节省请求次数，设置比较保守）

**问题**

需要测试节流的情景，特别同时有快速点击的。处理回应时，检查该回应是否需要被废弃。在处理异步回应时，如果使用了每次渲染重计算的值，这些参数可能会在请求与回复的等待过程中被修改而失效。节流下的程序运行情况很可能与网速正常时不同导致出错。

Middle组件可以显示三种数据，中间的处理流程尽量消除了对呈现数据的依赖，只在顶端获取不同数据，在底端对不同数据做一些定制化呈现。

在page组件中使用导入 Context.Provider 可以越过服务端组件实现两棵子树的叶组间件通信，以在切换url时保持witch数据种类。

state连锁更新。点选按钮切换，如果先改witchFetch状态（数据种类），然后引起监听这个变量的呈现数据（showData）状态的改变，会引起至少两次react渲染，不太必要，且容易出问题。在两次渲染切割的三个时间片中，中间时间片的数据是不相匹配的。
state监听渲染遇到新的setState会适时停止，不再调用子组件。
（这只是可以同步获取数据的情况，如果所切换的数据尚未缓存，那么第二个时间片要到异步请求的数据到达才结束，React渲染就会调用子组件，执行完中间时间片导致报错。因为有预抓取，在正常网速下这个情况不太会发生）

自定义钩子实现不具备泛用性，跟数据嵌合严重。

### home请求链

home页面是客户端组件页面，其关键路径过长，有三个存在依赖的请求，获取地理位置 -> 获取id -> 获取天气信息，一般在load事件之后才发起获取id的请求，而且地理位置需要用户许可权限才可以拿。
search页面比home页面快很多。

因为地理位置必须在客户端请求权限获取，没找到太好的方案，试了下中间件把默认页面重定向到search页面，search页面请求位置存进sessionStorage，切换到home时，直接从存储拿位置，在这种情况下可以省去第一个请求。
用useLayoutEffect会有五到十毫秒的微小提前，骨架屏在html里绘制好了，所以useLayoutEffect同步执行在这里没有影响。

后续对id的请求依赖没有继续优化。一个可行的优化方案是，在服务端缓存地理信息与id，这样客户端从sessionStorage获取地理信息后就可以直接请求天气信息，在理想情况下（从search跳转home后），可以消解掉请求链。

### 轮播图

参照B站网页执行情况实现。基本思路是每次移动将图片墙左移，显示位置从1滑动到2，然后将开头的图片挪到末尾，恢复显示位置到1；图片墙右移位置在1和0之间切换。定时器交替设置为1500ms和350ms（动画执行时间为300ms）。
有些繁琐的地方在于防止交互逻辑与动画执行流程产生冲突，动画执行，按钮交互和吃豆人交互的切换之间需要做状态清理。

左移流程：
```
（1500ms的定时器结束）setSlideOn(true) => 设置350ms的定时器，可视从1滑动到2，动画300ms -> 350ms的定时器结束，setSlideOn(false) => 图片墙头元素移到末尾，可视位置从2恢复到1，没有动画，设置1500ms的定时器 ->...
```

**Issues**

B站的吃豆人动画不会被光标悬停打断，是伪元素实现的；这个实现的动画是slidOn状态控制的，会被打断。

指针悬停到左右指针上不会暂停，这里有个冲突没有解决。点击吃豆人的交互不会设置slideOn为true，吃豆人和图片部分是可以悬停暂停的。

### 其他
**日出日落信息**

canvas绘制动画，折线的绘制考虑了刷新率适配。闪烁动画通过计算imageData坐标实现。图片存在清晰度问题，实现的时候canvas的缩放比和坐标偏移没被考虑。

**组件复用**

home页面做了响应式适配。 home和search主要是抓取数据方式不同，样式基本是同一套。但一部分代码直接复制使用，冗余较多。如果给它们加专门抓取数据的中间层，或者统一在page组件抓取，子组件基本都可以直接复用。

文件组织有些杂乱：数据抓取有两种方式，且工具函数存放不集中，组件全写进UI文件夹不是很方便切换

**部署**

Vercel的服务器存在时差，服务端渲染的页面用了本地时间，会报渲染不匹配的错误。国内服务器部署不会报这个错误。（印象里之前没有这个bug，也没有考虑到时区问题，Date对象处理不严谨）